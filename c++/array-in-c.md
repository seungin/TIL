# Array in C

C언어에서 배열은 기본적으로 제공되는 리스트의 형태이다. 하지만 배열이 어렵다고 생각하지는 않겠지만 정확하게 짚고 넘어가야 할 부분에 대해서 본 문서에서는 기술하도록 하겠다. 이를 위해 일반 변수와 배열을 비교하며 몇 가지 배열의 특징을 확인한다. 이 특징들은 C++ template을 이해하는 데에도 중요한 기본기가 된다.

## How to get an address of array

아래 코드에서 n은 변수명, int는 타입이다. 변수 n의 주소를 얻기 위해서는 동일한 선언(int pn)에서 변수명 앞에 *를 붙이면 된다. 그럼 배열은 어떨까? x는 변수명, int[3]이 타입이다. 변수 x의 주소를 얻기 위해서는 동일한 선언(int px[3])에서 변수명 앞에 *를 붙이면 된다. 그런데 에러가 난다. 왜냐하면 int *px[3] 에서 변수명 px 양 옆의 `*`와 `[` 두 연산자 중 우선 순위가 높은 [ 연산자가 먼저 수행되기 때문인데, 이 때는 괄호를 사용하면 된다. 즉, int (*px)[3]로 선언하면 배열의 주소를 얻을 변수를 선언할 수 있다.

```cpp
int n;
int* pn = &n;

int x[3] = { 1, 2, 3 };
int (*px)[3] = &x;
```

## Assignment of array

배열과 일반 변수의 차이점이 하나 있다. `배열은 자신과 동일한 타입으로 초기화될 수 없다.`

```cpp
int n1 = 10;
int n2 = n1;

int x1[3] = { 1, 2, 3 };
int x2[3] = x1; // Error! 배열은 자신과 동일한 타입으로 초기화할 수 없다!
```

## Decay of array

배열이 동일한 타입으로 초기화는 불가능하더라도 가능한 것이 한 가지 있다. `배열의 이름은 자신의 첫번째 요소의 주소 타입으로 암시적 형변환될 수 있다.`

```cpp
int x[3] = { 1, 2, 3 };
decltype(x[0])* p = x; // x[0] -> int
```

## Decay of array

동일한 타입으로 초기화는 불가능하더라도, `배열은 동일한 타입의 참조를 만들 수는 있다.`

```cpp
int x[3] = { 1, 2, 3}
int (&r)[3] = x;
```

## Summary

이를 요약하면 아래와 같다.

```cpp
int x[3] = { 1, 2, 3 };

int (*px)[3] = x; // 1. 배열의 포인터 타입 형태를 숙지하자.
int vx[3] = x;    // 2. 배열은 자신과 동일한 타입으로 초기화될 수 없다. 에러 발생!
int* ptr = x;     // 3. 배열의 이름은 자신의 첫번째 요소의 주소 타입으로 암시적 형변환될 수 있다.
int (&rx)[3] = x; // 4. 배열은 동일한 타입의 참조로 가리킬 수 있다.
```
